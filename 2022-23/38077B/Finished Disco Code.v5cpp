{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\ncontroller Controller1 = controller(primary);\nmotor Lefty = motor(PORT1, ratio18_1, false);\n\nmotor Righty = motor(PORT10, ratio18_1, true);\n\nlimit BotomLimitSwitch = limit(Brain.ThreeWirePort.A);\nlimit TopLimitSwitch = limit(Brain.ThreeWirePort.B);\nmotor BottomMotor = motor(PORT16, ratio18_1, false);\n\nmotor TopMotor = motor(PORT6, ratio6_1, false);\n\nmotor ShooterLeft = motor(PORT17, ratio6_1, false);\n\nmotor ShooterRight = motor(PORT18, ratio6_1, true);\n\ninertial Inertial13 = inertial(PORT13);\n\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n#pragma endregion VEXcode Generated Robot Configuration\n\n// Include the V5 Library\n#include \"vex.h\"\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\ncompetition Competition;\n\n// User defined functions\nvoid myblockfunction_Robot_Face();\nvoid myblockfunction_Smiley_Face();\nvoid myblockfunction_Endgame_Face();\nvoid ShowSpeeds(float left, float right, int row);\n\n// functions for printing, defined at the end of the file\nconst char* printToController1_numberFormat();\n\n// Global variables\nint Brain_precision = 0, Console_precision = 0, Controller1_precision = 0;\nevent message1 = event();\n// used to be global, made local, was... float LeftyVelocity, RightyVelocity;\n\n// Combine drive joystick and turn joystick to get intial motor speeds, which might exceed 100\n// input: joystick positions\n// side effects: modifies LeftSpeed and RightSpeed\nvoid MixDriveAndTurn (float driveStick, float turnStick, float &L, float &R) {\n  L = driveStick + turnStick;\n  R = driveStick - turnStick;\n}\n\n// Adjust speed settings to be normalized, so neither motor speed is > 100\n// input: joystick positions, and initial values of LeftSpeed and RightSpeed\n// side effects: modifies LeftSpeed and RightSpeed\nvoid NormalizeSpeeds(float driveStick, float turnStick, float &L, float &R) {\n  float totalStick = fabs(driveStick) + fabs(turnStick);\n  if (totalStick > 100.0) {\n    L = (L * 100.0) / totalStick;\n    R = (R * 100.0) / totalStick;\n  }\n}\n\n// \"when started\" hat block\nint whenStarted1() {\n\n  // initialize things\n  Brain.Timer.clear();\n  Lefty.setStopping(hold);\n  Righty.setStopping(hold);\n  TopMotor.setVelocity(100.0, percent);\n  BottomMotor.setVelocity(100.0, percent);\n\n  // forever loop...\n  while (true) {\n\n    // if any button pressed, do ... what?\n    if (Controller1.ButtonUp.pressing() || (Controller1.ButtonDown.pressing() || (Controller1.ButtonLeft.pressing() || (Controller1.ButtonRight.pressing() || (Controller1.ButtonX.pressing() || (Controller1.ButtonB.pressing() || (Controller1.ButtonY.pressing() || Controller1.ButtonA.pressing()))))))) {\n      Controller1.Screen.setCursor(1, 1);\n      Controller1.Screen.clearLine(1);\n      Controller1.Screen.setCursor(Controller1.Screen.row(), 1);\n      Controller1.Screen.print(\"No Function\");\n      wait(0.5, seconds);\n      Controller1.Screen.clearLine(1);\n      Controller1.Screen.setCursor(Controller1.Screen.row(), 1);\n    }\n\n    // display timer value on gamepad\n    // this is commented out  because the delay impacts responsiveness of the drive\n    // Controller1.Screen.setCursor(1, 1);\n    // Controller1.Screen.print(printToController1_numberFormat(), static_cast<float>(Brain.Timer.time(sec)));\n    // wait(0.1, seconds);\n    // Controller1.Screen.clearLine(1);\n    // Controller1.Screen.setCursor(Controller1.Screen.row(), 1);\n\n    // set drive motors according to joysticks using arcade method\n    float driveStick = Controller1.Axis3.position();\n    float turnStick = Controller1.Axis1.position();\n    float leftyVelocity = 0.0;\n    float rightyVelocity = 0.0;\n    MixDriveAndTurn(driveStick, turnStick, leftyVelocity, rightyVelocity);\n    NormalizeSpeeds(driveStick, turnStick, leftyVelocity, rightyVelocity);\n    Lefty.setVelocity(leftyVelocity, percent);\n    Righty.setVelocity(rightyVelocity, percent);\n    ShowSpeeds(leftyVelocity, rightyVelocity, 2);\n    Lefty.spin(forward);\n    Righty.spin(forward);\n\n    // check limit switches\n    if (TopLimitSwitch.pressing()) {\n      Controller1.rumble(\"....\");\n      while (TopLimitSwitch.pressing()) {\n        TopMotor.stop();\n        wait(5, msec);\n        // what gets you out of this loop?  You will get stuck here as long as limit switch pressed\n      }\n    }\n\n    // control intake using buttons\n    if (!Controller1.ButtonR1.pressing() || !Controller1.ButtonR2.pressing()) {\n      BottomMotor.stop();\n    }\n    if (!Controller1.ButtonL1.pressing() || !Controller1.ButtonL2.pressing()) {\n      TopMotor.stop();\n    }\n    if (TopLimitSwitch.pressing() && BotomLimitSwitch.pressing()) {\n      Controller1.Screen.setCursor(3, 1);\n      Controller1.rumble(\"-.-.\");\n      repeat(7) {\n        Controller1.Screen.print(\"Disks loaded\");\n        wait(0.3, seconds);\n        Controller1.Screen.clearScreen();\n        wait(5, msec);\n      }\n      while ((TopLimitSwitch.pressing() && BotomLimitSwitch.pressing())) {\n        TopMotor.stop();\n        BottomMotor.stop();\n      wait(5, msec);\n      }\n    }\n    if (Controller1.ButtonL1.pressing()) {\n      BottomMotor.spin(reverse);\n    }\n    if (Controller1.ButtonL2.pressing()) {\n      BottomMotor.spin(forward);\n    }\n    if (Controller1.ButtonR1.pressing()) {\n      TopMotor.spin(reverse);\n    }\n    if (Controller1.ButtonR2.pressing()) {\n      TopMotor.spin(forward);\n    }\n\n  // delay a little before starting loop again\n  wait(5, msec);\n  }\n  return 0;\n}\n\n// \"when autonomous\" hat block\nint onauton_autonomous_0() {\n  myblockfunction_Robot_Face();\n  return 0;\n}\n\n// \"when Brain timer\" hat block\nvoid onevent_Brain_timer_0() {\n  myblockfunction_Endgame_Face();\n}\n\n// \"when driver control\" hat block\nint ondriver_drivercontrol_0() {\n  myblockfunction_Smiley_Face();\n  return 0;\n}\n\nvoid VEXcode_driver_task() {\n  // Start the driver control tasks....\n  vex::task drive0(ondriver_drivercontrol_0);\n  while(Competition.isDriverControl() && Competition.isEnabled()) {this_thread::sleep_for(10);}\n  drive0.stop();\n  return;\n}\n\nvoid VEXcode_auton_task() {\n  // Start the auton control tasks....\n  vex::task auto0(onauton_autonomous_0);\n  while(Competition.isAutonomous() && Competition.isEnabled()) {this_thread::sleep_for(10);}\n  auto0.stop();\n  return;\n}\n\n\n\nint main() {\n  vex::competition::bStopTasksBetweenModes = false;\n  Competition.autonomous(VEXcode_auton_task);\n  Competition.drivercontrol(VEXcode_driver_task);\n\n  // register event handlers\n  Brain.Timer.event(onevent_Brain_timer_0,16000);\n\n  wait(15, msec);\n  // post event registration\n\n  // set default print color to black\n  printf(\"\\033[30m\");\n\n  // wait for rotation sensor to fully initialize\n  wait(30, msec);\n\n  whenStarted1();\n}\n\n// User defined function\nvoid myblockfunction_Robot_Face() {\n  Brain.Screen.clearScreen();\n  Brain.Screen.setPenColor(black);\n  Brain.Screen.drawPixel(22, 2);\n  Brain.Screen.drawPixel(25, 2);\n  Brain.Screen.drawPixel(21, 3);\n  Brain.Screen.drawPixel(22, 3);\n  Brain.Screen.drawPixel(25, 3);\n  Brain.Screen.drawPixel(26, 3);\n  Brain.Screen.drawPixel(22, 4);\n  Brain.Screen.drawPixel(25, 4);\n  Brain.Screen.drawPixel(21, 5);\n  Brain.Screen.drawPixel(22, 5);\n  Brain.Screen.drawPixel(23, 5);\n  Brain.Screen.drawPixel(24, 5);\n  Brain.Screen.drawPixel(25, 5);\n  Brain.Screen.drawPixel(26, 5);\n  Brain.Screen.drawPixel(21, 6);\n  Brain.Screen.drawPixel(21, 7);\n  Brain.Screen.drawPixel(21, 8);\n  Brain.Screen.drawPixel(21, 9);\n  Brain.Screen.drawPixel(21, 10);\n  Brain.Screen.drawPixel(21, 11);\n  Brain.Screen.drawPixel(22, 11);\n  Brain.Screen.drawPixel(23, 11);\n  Brain.Screen.drawPixel(24, 11);\n  Brain.Screen.drawPixel(25, 11);\n  Brain.Screen.drawPixel(26, 11);\n  Brain.Screen.drawPixel(26, 6);\n  Brain.Screen.drawPixel(26, 7);\n  Brain.Screen.drawPixel(26, 8);\n  Brain.Screen.drawPixel(26, 9);\n  Brain.Screen.drawPixel(26, 10);\n  Brain.Screen.setPenColor(red);\n  Brain.Screen.drawPixel(22, 6);\n  Brain.Screen.drawPixel(22, 7);\n  Brain.Screen.drawPixel(25, 6);\n  Brain.Screen.drawPixel(25, 7);\n  Brain.Screen.drawPixel(23, 9);\n  Brain.Screen.drawPixel(24, 9);\n}\n\n// User defined function\nvoid myblockfunction_Smiley_Face() {\n  Brain.Screen.clearScreen();\n  Brain.Screen.setPenColor(black);\n  Brain.Screen.drawPixel(23, 5);\n  Brain.Screen.drawPixel(23, 6);\n  Brain.Screen.drawPixel(23, 7);\n  Brain.Screen.drawPixel(26, 5);\n  Brain.Screen.drawPixel(26, 6);\n  Brain.Screen.drawPixel(26, 7);\n  Brain.Screen.drawPixel(22, 9);\n  Brain.Screen.drawPixel(27, 9);\n  Brain.Screen.drawPixel(23, 10);\n  Brain.Screen.drawPixel(24, 10);\n  Brain.Screen.drawPixel(25, 10);\n  Brain.Screen.drawPixel(26, 10);\n}\n\n// User defined function\nvoid myblockfunction_Endgame_Face() {\n  Brain.Screen.clearScreen();\n  Brain.Screen.setPenColor(black);\n  Brain.Screen.drawPixel(23, 5);\n  Brain.Screen.drawPixel(23, 6);\n  Brain.Screen.drawPixel(23, 7);\n  Brain.Screen.drawPixel(26, 5);\n  Brain.Screen.drawPixel(26, 6);\n  Brain.Screen.drawPixel(26, 7);\n  Brain.Screen.drawPixel(22, 9);\n  Brain.Screen.drawPixel(27, 9);\n  Brain.Screen.drawPixel(23, 10);\n  Brain.Screen.drawPixel(24, 10);\n  Brain.Screen.drawPixel(25, 10);\n  Brain.Screen.drawPixel(26, 10);\n  Brain.Screen.drawPixel(23, 2);\n  Brain.Screen.drawPixel(26, 2);\n  Brain.Screen.drawPixel(24, 3);\n  Brain.Screen.drawPixel(25, 3);\n}\n\n// Used to find the format string for printing numbers with the\n// desired number of decimal places\nconst char* printToController1_numberFormat() {\n  // look at the current precision setting to find the format string\n  switch(Controller1_precision){\n    case 0:  return \"%.0f\"; // 0 decimal places (1)\n    case 1:  return \"%.1f\"; // 1 decimal place  (0.1)\n    case 2:  return \"%.2f\"; // 2 decimal places (0.01)\n    case 3:  return \"%.3f\"; // 3 decimal places (0.001)\n    default: return \"%f\"; // use the print system default for everthing else\n  }\n}\n\n// Display speeds on brain\nvoid ShowSpeeds(float left, float right, int row) {\n  Controller1.Screen.setCursor(row, 1);\n  Controller1.Screen.clearLine(row);\n  Controller1.Screen.setCursor(Controller1.Screen.row(), 1);\n  Controller1.Screen.print(printToController1_numberFormat(), left);\n  Controller1.Screen.print(\" \");\n  Controller1.Screen.print(printToController1_numberFormat(), right);\n}\n","textLanguage":"cpp","rconfig":[{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[1],"name":"Lefty","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[10],"name":"Righty","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[1],"name":"BotomLimitSwitch","customName":true,"deviceType":"LimitSwitch","deviceClass":"limit","setting":{"id":"partner"},"triportSourcePort":22},{"port":[2],"name":"TopLimitSwitch","customName":true,"deviceType":"LimitSwitch","deviceClass":"limit","setting":{"id":"partner"},"triportSourcePort":22},{"port":[16],"name":"BottomMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[6],"name":"TopMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[17],"name":"ShooterLeft","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[18],"name":"ShooterRight","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[13],"name":"Inertial13","customName":false,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22}],"slot":6,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.0","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}