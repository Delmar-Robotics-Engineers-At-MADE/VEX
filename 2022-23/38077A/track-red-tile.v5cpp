{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\n/*vex-vision-config:begin*/\nvision::signature Vision21__SIG_1 = vision::signature (1, 6139, 6653, 6396,-669, -243, -456,3, 0);\nvision::signature Vision21__SIG_2 = vision::signature (2, 0, 0, 0,0, 0, 0,3, 0);\nvision Vision21 = vision (PORT21, 51, Vision21__SIG_1, Vision21__SIG_2);\n/*vex-vision-config:end*/\ncontroller Controller1 = controller(primary);\nmotor LeftDriveSmart = motor(PORT1, ratio18_1, false);\nmotor RightDriveSmart = motor(PORT10, ratio18_1, true);\ngyro DrivetrainGyro = gyro(Brain.ThreeWirePort.B);\nsmartdrive Drivetrain = smartdrive(LeftDriveSmart, RightDriveSmart, DrivetrainGyro, 319.19, 320, 40, mm, 1);\n\n\nvoid calibrateDrivetrain() {\n  wait(200, msec);\n  Brain.Screen.print(\"Calibrating\");\n  Brain.Screen.newLine();\n  Brain.Screen.print(\"Gyro\");\n  DrivetrainGyro.calibrate();\n  while (DrivetrainGyro.isCalibrating()) {\n    wait(25, msec);\n  }\n\n  // Clears the screen and returns the cursor to row 1, column 1.\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1, 1);\n}\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n#pragma endregion VEXcode Generated Robot Configuration\n// Include the V5 Library\n#include \"vex.h\"\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// User defined functions\nint FindBestVisionObject(bool visualize);\nvoid TurnToBestObject(int objIndex);\n\n// int Vision21_objectIndex = 0;\n\n// float objectCount, i, bestAspect, area, bestIndex, aspectRatio, aspectError, MaxAspectError, TargetAspect, bestAspectError, MinimumArea, MinAspectError, BaseForAngleCalc, XTolerance;\n\n// Global constants\nstatic  float XTolerance = 30.0;\nstatic  float BaseForAngleCalc = 160.0;\nstatic  float MinimumArea = 10000.0;\nstatic  float TargetAspect = 100.0;\nstatic  float MaxAspectError = 1.5;\nstatic  float MinAspectError = 0.7;\n\n// User defined function\nint FindBestVisionObject(bool visualize) {\n  int i = 0;\n  int bestIndex = 0;\n  float bestAspectError = 0.0;\n  float bestAspect = 0.0;\n  while ((i < Vision21.objectCount)) {\n    Brain.Screen.setFillColor(white);\n    float area = Vision21.objects[i].width * Vision21.objects[i].height;\n    if (area > MinimumArea) {\n      Brain.Screen.setFillColor(green);\n      float aspectRatio = (Vision21.objects[i].height * 100.0) / Vision21.objects[i].width;\n      float aspectError = aspectRatio / TargetAspect;\n      if (aspectError < MaxAspectError && aspectError > MinAspectError) {\n        Brain.Screen.setFillColor(red);\n        bestIndex = i;\n        bestAspectError = aspectError;\n        bestAspect = aspectRatio;\n      }\n    }\n    i++;\n  wait(5, msec);\n  }\n  if (visualize) {\n    Brain.Screen.clearScreen();\n    Brain.Screen.drawRectangle(200, 50, Vision21.objects[bestIndex].width, Vision21.objects[bestIndex].height);\n  }\n  return (bestIndex);\n}\n\n// User defined function\nvoid TurnToBestObject(int objIndex) {\n  if (fabs(static_cast<float>(Vision21.objects[objIndex].centerX - 180.0)) > XTolerance) {\n    Drivetrain.turnToHeading(\n      Drivetrain.heading() + atan((Vision21.objects[objIndex].centerX - 180.0) / BaseForAngleCalc) * 180 / M_PI, \n      degrees, true);\n  }\n  else {\n    Drivetrain.stop();\n  }\n}\n\n// \"when started\" hat block\nint whenStarted1() {\n  Brain.Screen.setFillColor(red);\n  Drivetrain.setStopping(coast);\n  Drivetrain.setTurnVelocity(100.0, percent);\n  Drivetrain.setHeading(0.0, degrees);\n\n  while (true) {\n    Vision21.takeSnapshot(Vision21__SIG_1);\n    if (Vision21.objectCount > 0) {\n      int bestObjIndex = FindBestVisionObject(true);\n      TurnToBestObject(bestObjIndex);\n    }\n    else {\n      Drivetrain.stop();\n    }\n  wait(5, msec);\n  }\n  return 0;\n}\n\n\nint main() {\n  // Calibrate the Drivetrain\n  calibrateDrivetrain();\n\n  // post event registration\n\n  // set default print color to black\n  printf(\"\\033[30m\");\n\n  // wait for rotation sensor to fully initialize\n  wait(30, msec);\n\n  whenStarted1();\n}","textLanguage":"cpp","rconfig":[{"port":[21],"name":"Vision21","customName":false,"deviceType":"Vision","deviceClass":"vision","setting":{"config":"{\"config\":{\"brightness\":51,\"signatures\":[{\"name\":\"SIG_1\",\"parameters\":{\"uMin\":6139,\"uMax\":6653,\"uMean\":6396,\"vMin\":-669,\"vMax\":-243,\"vMean\":-456,\"rgb\":12808556,\"type\":0,\"name\":\"SIG_1\"},\"range\":3},{\"name\":\"SIG_2\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_2\"},\"range\":3},{\"name\":\"SIG_3\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_3\"},\"range\":2.5},{\"name\":\"SIG_4\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_4\"},\"range\":2.5},{\"name\":\"SIG_5\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_5\"},\"range\":2.5},{\"name\":\"SIG_6\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_6\"},\"range\":2.5},{\"name\":\"SIG_7\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_7\"},\"range\":2.5}],\"codes\":[]}}","isConfigured":"false"},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[1,10,2],"name":"Drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"wheel4in","gear":"ratio18_1","gearRatio":"1:1","direction":"fwd","gyroType":"threewire","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":22}],"slot":1,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"","minVersion":"2.4.0","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}